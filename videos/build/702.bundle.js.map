{"version":3,"file":"702.bundle.js","mappings":";;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["./node_modules/three/src/textures/VideoTexture.js"],"sourcesContent":["import { LinearFilter } from '../constants.js';\nimport { Texture } from './Texture.js';\n\n/**\n * A texture for use with a video.\n *\n * ```js\n * // assuming you have created a HTML video element with id=\"video\"\n * const video = document.getElementById( 'video' );\n * const texture = new THREE.VideoTexture( video );\n * ```\n *\n * Note: When using video textures with {@link WebGPURenderer}, {@link Texture#colorSpace} must be\n * set to THREE.SRGBColorSpace.\n *\n * Note: After the initial use of a texture, its dimensions, format, and type\n * cannot be changed. Instead, call {@link Texture#dispose} on the texture and instantiate a new one.\n *\n * @augments Texture\n */\nclass VideoTexture extends Texture {\n\n\t/**\n\t * Constructs a new video texture.\n\t *\n\t * @param {HTMLVideoElement} video - The video element to use as a data source for the texture.\n\t * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.\n\t * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.\n\t * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.\n\t * @param {number} [magFilter=LinearFilter] - The mag filter value.\n\t * @param {number} [minFilter=LinearFilter] - The min filter value.\n\t * @param {number} [format=RGBAFormat] - The texture format.\n\t * @param {number} [type=UnsignedByteType] - The texture type.\n\t * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.\n\t */\n\tconstructor( video, mapping, wrapS, wrapT, magFilter = LinearFilter, minFilter = LinearFilter, format, type, anisotropy ) {\n\n\t\tsuper( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\t\t/**\n\t\t * This flag can be used for type testing.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @readonly\n\t\t * @default true\n\t\t */\n\t\tthis.isVideoTexture = true;\n\n\t\t/**\n\t\t * Whether to generate mipmaps (if possible) for a texture.\n\t\t *\n\t\t * Overwritten and set to `false` by default.\n\t\t *\n\t\t * @type {boolean}\n\t\t * @default false\n\t\t */\n\t\tthis.generateMipmaps = false;\n\n\t\t/**\n\t\t * The video frame request callback identifier, which is a positive integer.\n\t\t *\n\t\t * Value of 0 represents no scheduled rVFC.\n\t\t *\n\t\t * @private\n\t\t * @type {number}\n\t\t */\n\t\tthis._requestVideoFrameCallbackId = 0;\n\n\t\tconst scope = this;\n\n\t\tfunction updateVideo() {\n\n\t\t\tscope.needsUpdate = true;\n\t\t\tscope._requestVideoFrameCallbackId = video.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t\tif ( 'requestVideoFrameCallback' in video ) {\n\n\t\t\tthis._requestVideoFrameCallbackId = video.requestVideoFrameCallback( updateVideo );\n\n\t\t}\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor( this.image ).copy( this );\n\n\t}\n\n\t/**\n\t * This method is called automatically by the renderer and sets {@link Texture#needsUpdate}\n\t * to `true` every time a new frame is available.\n\t *\n\t * Only relevant if `requestVideoFrameCallback` is not supported in the browser.\n\t */\n\tupdate() {\n\n\t\tconst video = this.image;\n\t\tconst hasVideoFrameCallback = 'requestVideoFrameCallback' in video;\n\n\t\tif ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tdispose() {\n\n\t\tif ( this._requestVideoFrameCallbackId !== 0 ) {\n\n\t\t\tthis.source.data.cancelVideoFrameCallback( this._requestVideoFrameCallbackId );\n\n\t\t\tthis._requestVideoFrameCallbackId = 0;\n\n\t\t}\n\n\t\tsuper.dispose();\n\n\t}\n\n}\n\nexport { VideoTexture };\n"],"names":[],"sourceRoot":""}